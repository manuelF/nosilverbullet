\documentclass{beamer}
\usepackage{etex}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage[all]{xy}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{stmaryrd}
%\usepackage{qtree}
%\usepackage{hyperref}
\usepackage{listings}
\usepackage{mathrsfs}

\usepackage[spanish]{babel}
\uselanguage{Spanish}
\languagepath{Spanish}

\AtBeginDocument{\shorthandoff{"}}

\definecolor{color_titulo}{rgb}{0.25,.45,.25}
%\newcommand{\J}[1]{\textcolor{blue}{#1}}
\newcommand{\HS}{\hspace{.5cm}}

\begin{document}
{
\usebackgroundtemplate{ \includegraphics[width=11cm]{34d48c3.jpg}}
\frame[plain]{
\vspace{4cm}
\begin{center}
 {\LARGE \textcolor{color_titulo}{{\em No Silver Bullet}}}\\
 \vspace{.25cm}
 {\large Presentaci\'on de papers fundacionales -- Grupo $5$}\\
 \vspace{.5cm}
 {\bf {Ingenier\'ia del Software $2$}}\\
 \vspace{.5cm}
 {\small
    Facultad de Ciencias Exactas y Naturales\\
    Universidad de Buenos Aires \\
    $17$ de noviembre de $2014$ }
\end{center}
}
}

\begin{frame}[fragile]
  \frametitle{Qui\'en es \textit{Frederick P. Brooks, Jr.}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introducci\'on}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Dificultades esenciales}

  A diferencia del mundo del \textit{hardware} no podemos esperar que nuestra
  capacidad de producir buen \textit{sofware} se doble cada a\~no.

  De hecho, deber\'iamos considerar el caso del \textit{hardware} como una
  excepci\'on.

  La esencia de una entidad de \textit{software} es el resultado de la
  composici\'on no trivial de varios conceptos:
  \begin{itemize}
    \item conjuntos de datos
    \item relaciones entre datos
    \item algoritmos
    \item invocaci\'on de funciones
  \end{itemize}

  La parte dif\'icil de construir \textit{software} es la
  \textbf{especificaci\'on}, \textbf{dise\~no} y \textbf{testeo} de estos
  conceptos.
  La dificultad \textbf{no se encuentra} en la representaci\'on y el testeo
  de la fidelidad de la representaci\'on.

  \textbf{Los errores sint\'acticos son muy menores en comparaci\'on a los
  errores conceptuales en la mayor\'ia de los sistemas.}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Complejidad}

  Las entidades de \textit{software} son complejas porque dos partes en un
  \textit{software} nunca son semejantes, si as\'i lo fuera, uno deber\'ia
  abstraerlas en una misma subrutina. Por este motivo el \textit{software}
  se diferencia de las computadoras, los edificios o los autom\'obiles, donde
  los elementos repetidos abundan.

  Lograr que una entidad de \textit{software} escale es complejo, pues los
  elementos interactuan de forma no lineal.

  La complejidad del \textit{software} es esencial, no accidental. Por lo tanto
  descripciones que abstraigan esta complejidad suelen abstraer la esencia.

  La complejidad genera:
  \begin{itemize}
    \item dificultad en la comunicaci\'on de un equipo
      $\mapsto$ fallas, costo, atraso del proyecto
    \item dificultad en la enumeraci\'on de los estados de un programa
      $\mapsto$ baja confiabilidad en el programa
    \item complejidad en las funciones
      $\mapsto$ dificultad en el uso de las mismas
    \item complejidad en las estructuras usadas
      $\mapsto$ dificultades en la modificabilidad, problemas de seguridad
  \end{itemize}

\end{frame}


\begin{frame}[fragile]
  \frametitle{\textit{Conformity} (adaptaci\'on)}

  La f\'isica, y otras disciplinas, deben lidiar con objetos complejos, pero
  se basan en la expectativa de encontrar teor\'ias unificadas.
  Esta expectativa no conforta a la ingenier\'ia del \textit{software}.

  La complejidad con la que se encuentra una entidad de \textit{software}
  es arbitraria, generada por las muchas instituciones humanas y sistemas
  a los cuales, sus interfaces, deben acatar.

  En los (muchos) casos en que una entidad de \textit{software} debe adaptarse
  a otras interfaces, la complejidad que esto genera no puede ser simplificada
  por ning\'un redise\~no que incluya \'unicamente a dicha entidad.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Modificabilidad}
  A diferencia de los objetos manufacturados \textit{f\'isicamente} (edificios,
  autom\'obiles o computadoras), las entidades de \textit{software} continuamente
  est\'an siendo forzadas a cambiar.

  Los motivos principales son dos:
  \begin{itemize}
    \item la funcionalidad de un sistema suele necesitar extenderse o modificarse
    \item a diferencia de objetos f\'isicamente concretos, el \textit{software}
      es infinitamente modificable
  \end{itemize}

  Un sistema exitoso sufrir\'a modificaciones. Mientras se lo encuentre \'util,
  los usuarios lo utilizar\'an en escenarios no contemplados, en otros dominios.
  M\'as a\'un, un sistema exitoso sobrevivir\'a a las maquinas para las cuales
  fue inicialmente construido, que, sabemos, cambian continuamente.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Invisibilidad}
  El \textit{software} es invisibile, \textit{invisualizable}.
  Las abstracciones geom\'etricas suelen resaltar inconsistencias, pero
  la realidad del \textit{software} no est\'a naturalmente embebida
  en un espacio.

  Las herramientas m\'as comunes para la visualizaci\'on suelen ser poco claras,
  pues vemos demasiadas conexiones. Suele ser buena pr\'actica limitar los
  \textit{links} y preferir los grafos \textbf{jer\'arquicos}.

  La visualizaci\'on geom\'etrica es una de las herramientas conceptuales m\'as
  importantes de la mente humana. La dificultad de visualizar el \textit{software}
  no solo limita el dise\~no de una mente, \textbf{limita la comunicaci\'on entre
  varias mentes}.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Dificultades accidentales resueltas}

  \begin{itemize}
    \item[Lenguajes de alto nivel]
      Liberaron a los programas de mucha de su complejidad accidental.
      Nuesta sofisticaci\'on en c\'omo pensar las estructuras de datos, los tipos
      de datos y las operaciones, se encuentra en crecimiento, pero es un crecimiento
      cada vez m\'as limitado.
    \item[Tiempo compartido]
      El efecto principal es la r\'apida respuesta de un sistema. A medida que
      tiende a cero, el \textit{delay} se torna imperceptible. Mas all\'a de
      este punto no pueden esperarse beneficios particularmente importantes.
    \item[Ambientes de programaci\'on unificados]
      Atacan a las dificultades accidentales de comunicar m\'ultiples programas.
  \end{itemize}
\end{frame}


%\begin{frame}[fragile]
%  \frametitle{Candidatos a \textit{silver bullet}}
%
%  El lenguaje \textsc{Ada}.
%  Esta secci\'on qued\'o un poco desactualizada, dada la enorme cantidad de
%  lenguajes de alto nivel, especializados en resolver gran parte de los
%  problemas accidentales con que se encuentra un programador.
%
%  TODO: leer un poco sobre Ada.
%\end{frame}


\begin{frame}[fragile]
  \frametitle{Programaci\'on orientada a objetos}
  Separamos dos conceptos ortogonales que llevan el mismo nombre.
  \begin{itemize}
    \item[Tipos abstractos de datos] El tipo de un objeto debe ser
      definido por un nombre, un conjunto de valores propios, y un conjunto
      de operaciones propias. \textbf{No} por su estructura interna.
    \item[Tipos jer\'arquicos] Permiten la definici\'on de interfaces generales
      que se pueden ir refinando, siempre que se lo necesite.
  \end{itemize}

  Dada su ortogonalidad pueden ser usados independientemente.
  Permiten evitar las dificultades accidentales de la implementaci\'on de un
  dise\~no, pero \textbf{la complejidad del dise\~no sigue siendo esencial}.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Inteligencia artificial}
  Si bien muchas personas creen que la inteligencia artificial ser\'a la
  revoluci\'on que dar\'a mejoras de un orden de magnitud en productividad
  y calidad de \textit{software}, el autor no concuerda.

  Las t\'ecnicas utilizadas para reconocimiento de voz parecen tener muy
  poco que ver con las utilizadas en reconocimiento de im\'agenes y ambas
  parecen muy distintas de las utilizadas en sistemas expertos.
  Esto da la idea de que no se tienen t\'ecnicas generales para resolver
  problemas de \textit{decisi\'on}.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Sistemas expertos}

  Un ejemplo interesante que se da es el un (potencial) sistema experto que
  funciona como asistente de testeo.
  A medida que se desarrolla una aplicaci\'on, el sistema va adquiriendo reglas,
  pasando de sugerencias muy generales a sugerencias cada vez m\'as relacionadas
  con la estructura del sistema.

  El trabajo requerido para generar las reglas de diagn\'ostico es trabajo
  que deber\'a hacerse de todas formas. Si este es hecho de forma suficientemente
  general podr\'ia reducir la cantidad de trabajo a largo plazo.

  La contribuci\'on principal que puede dar un sistema experto es cuando se lo
  pone a servicio de programadores sin experiencia. Una herramienta que facilite
  y recomiende buenas pr\'acticas puede ser muy importante.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Programaci\'on ``autom\'atica'' y programaci\'on gr\'afica}
  \begin{itemize}
    \item La \textbf{programaci\'on autom\'atica} es un concepto que existe desde la d\'ecada del 60:
  hacer que el c\'odigo de alguna manera, se escriba solo. Seg\'un Brooks y Parnas,
  este concepto es puro \textit{glamour}, solo es programar con un nivel de abstracci\'on
  una capa superior.

  \item La \textbf{programaci\'on gr\'afica} tambi\'en es puesta al costado por Brooks, no es posible
  representar el problema esencial del software en dos dimensiones, los diagramas
  de flujos, clases, etc. son pobres representaciones de un problema multi dimensional,
  el espacio finito no ayuda.
\end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Verificaci\'on y desarrollo}
  \begin{itemize}
\item La \textbf{verificaci\'on de programas} es un problema dif\'icil de resolver en los casos
  no-triviales, ni tampoco garantizan que no tengan bugs. Solamente se puede
  probar que condicen con una especificaci\'on hecha a mano. Construir la especificaci\'on
  de lo que se quiere construir es la tarea mas dif\'icil del software.
\item En los \textbf{entornos de desarrollo}, los grandes inconvenientes han sido resueltos: los formatos de archivos se han
  estandarizado, las interfaces de desarrollo son \'utiles y compilar no tarda horas en
  la mayor\'ia de los casos. Se propone usar bases de datos donde guardar los detalles
  del sistema para facilitar la comprensi\'on del c\'odigo.
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Ataques prometedores contra la esencia conceptual}
  Comprar \textit{vs.} construir \\
  La mejor manera de acelerar el desarrollo es no desarrollar. Con el avance de las
  librer\'ias estandarizadas y programas ofim\'aticas gen\'ericos, mucho de lo que se hacia
  in-house ahora se puede comprar, a costos muy inferiores al de desarrollarlo y teni\'endolo
  ya. Las empresas han dado el brazo a torcer: no se requiere que los productos se ajusten a
  los mecanismos actuales sino que ajustan los mecanismos a los productos, para abaratar costos
  y estandarizarse.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Refinamiento de requerimientos y prototipado r\'apido}
  La decisi\'on mas dif\'icil en la construcci\'on del software es \textbf{que software construir}. Esto
  compone obtener los requerimientos necesarios para poder determinar cuales son los relevantes y
  prioritarios y cuales son accidentales nomas. El problema de definir que quiere un cliente
  es, seg\'un Brooks, imposible sin un producto en las manos para que pueda decir si eso es lo
  que tenia en mente.

  Lo mas importante de todo entonces, va a ser poder desarrollar m\'etodos y herramientas para
  construir prototipos r\'apidos, y solo una vez validados con el cliente, se deben seguir
  agregando funcionalidades. Evitar crear software por comit\'e y licitaci\'on a caja cerrada.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Desarrollo incremental -- \textit{grow vs. build}}
  Las met\'aforas de construcci\'on del software no aplican ya. Las estructuras conceptuales son muy
  complicadas para poderse determinar de antemano. Hay que aplicar el concepto de la vida y la naturaleza,
  donde se crece incrementalmente, para poder agregar mas caracter\'isticas y cumplir nuevos prop\'ositos.
  Top-down sobre bottom-up.
\end{frame}
%
%\begin{frame}[fragile]
%  \frametitle{Grandes dise\~nadores}
%  El software hecho por un \'unico grupo de pocos y grandes dise\~nadores cuenta con visi\'on consistente
%  y fan\'atica comparado con los hechos por comit\'e. El dise\~no se puede ense\~nar pero lleva tiempo
%  y no es algo que parezca importante a las empresas a simple vista. Brooks sugiere incentivar y
%  cultivar personas en este \'area, para poder lograr productos de excelencia.
%\end{frame}

\begin{frame}[fragile]
  \frametitle{Conclusiones -- moraleja}
  Seg\'un Brooks, ninguna \'unica mejora puede aumentar diez veces la productividad del desarrollo de software.
  Su complejidad es tan alta y es tan distinta a las otras disciplinas que todav\'ia no sabemos cuales
  son las mejores herramientas para la tarea.

  Las mejores practicas consisten en eliminar complejidad en todo nivel posible, sin creer que cada
  mejora por separado puede ser la panacea de la ingenier\'ia del software.
\end{frame}
\end{document}

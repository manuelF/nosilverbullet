\documentclass{beamer}
\usepackage{etex}
\usepackage[utf8]{inputenc}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage[all]{xy}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{stmaryrd}
%\usepackage{qtree}
%\usepackage{hyperref}
\usepackage{listings}
\usepackage{mathrsfs}

\usepackage[spanish]{babel}
\uselanguage{Spanish}
\languagepath{Spanish}

\AtBeginDocument{\shorthandoff{"}}

%%%% Inductive rules with prooftree
%\input{prooftree.tex}
%\newcommand{\indrulename}[1]{\textsc{#1}}
%\newcommand{\indrule}[3]{
%\ensuremath{
%\begin{array}{c}
%  \prooftree #2
%    \justifies #3
%    \thickness=0.05em
%    \using \indrulename{#1}
%  \endprooftree
%\end{array}}}

%\beamertemplatenavigationsymbolsempty

\definecolor{color_titulo}{rgb}{0.25,.45,.25}
%\newcommand{\J}[1]{\textcolor{blue}{#1}}
%\newcommand{\HS}{\hspace{.5cm}}
%\newcommand{\Bool}{\mathbb{B}}
%\newcommand{\fv}[1]{\textsf{fv}(#1)}
%\newcommand{\Nat}{\mathbb{N}}
%\newcommand{\refl}{\textsf{refl}}
%\newcommand{\ap}{\textsf{ap}}
%\newcommand{\apd}{\textsf{apd}}
%\newcommand{\lift}{\textsf{lift}}
%\newcommand{\tr}{\textsf{tr}}
%\newcommand{\id}{\textsf{id}}
%\newcommand{\ind}{\textsf{ind}}
%\newcommand{\rec}{\textsf{rec}}
%\newcommand{\U}{\mathcal{U}}
%\newcommand{\ctx}{\,\textsf{ctx}}
%%\newcommand{\eq}[1]{\,=\raisebox{-.1cm}{\ensuremath{_{\!\!#1}}}\,}
%\newcommand{\eq}[1]{\,=_{#1}\,}
%\newcommand{\A}[1]{\Pi_{(#1)}}
%\newcommand{\E}[1]{\Sigma_{(#1)}}
%\newcommand{\whil}{\bullet_{\ell}}
%\newcommand{\whir}{\bullet_{r}}

\begin{document}
{
%\usebackgroundtemplate{\includegraphics[width=12.8cm]{hott.png}}
\frame[plain]{
\vspace{4cm}
\begin{center}
 {\LARGE \textcolor{color_titulo}{{\em Homotopy Type Theory}}}\\
 \vspace{.25cm}
 {\large Tercer encuentro -- 18 de septiembre de 2014}\\
 \vspace{.5cm}
 {\bf {Espacio sobre temas de programaci\'on funcional}}\\
 \vspace{.5cm}
 {\small
    Facultad de Ciencias Exactas y Naturales\\
    Universidad de Buenos Aires \\
    2014 }
\end{center}
}
}

\begin{frame}[fragile]
  \frametitle{Qui\'en es \textit{Frederick P. Brooks, Jr.}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Introducci\'on}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Dificultades esenciales}

  A diferencia del mundo del \textit{hardware} no podemos esperar que nuestra
  capacidad de producir buen \textit{sofware} se doble cada a\~no.

  De hecho, deber\'iamos considerar el caso del \textit{hardware} como una
  excepci\'on.

  La esencia de una entidad de \textit{software} es el resultado de la
  composici\'on no trivial de varios conceptos:
  \begin{itemize}
    \item conjuntos de datos
    \item relaciones entre datos
    \item algoritmos
    \item invocaci\'on de funciones
  \end{itemize}

  La parte dif\'icil de construir \textit{software} es la
  \textbf{especificaci\'on}, \textbf{dise\~no} y \textbf{testeo} de estos
  conceptos.
  La dificultad \textbf{no se encuentra} en la representaci\'on y el testeo
  de la fidelidad de la representaci\'on.

  \textbf{Los errores sint\'acticos son muy menores en comparaci\'on a los
  errores conceptuales en la mayor\'ia de los sistemas.}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Complejidad}

  Las entidades de \textit{software} son complejas porque dos partes en un
  \textit{software} nunca son semejantes, si as\'i lo fuera, uno deber\'ia
  abstraerlas en una misma subrutina. Por este motivo el \textit{software}
  se diferencia de las computadoras, los edificios o los autom\'obiles, donde
  los elementos repetidos abundan.

  Lograr que una entidad de \textit{software} escale es complejo, pues los
  elementos interactuan de forma no lineal.

  La complejidad del \textit{software} es esencial, no accidental. Por lo tanto
  descripciones que abstraigan esta complejidad suelen abstraer la esencia.

  La complejidad genera:
  \begin{itemize}
    \item dificultad en la comunicaci\'on de un equipo
      $\mapsto$ fallas, costo, atraso del proyecto
    \item dificultad en la enumeraci\'on de los estados de un programa
      $\mapsto$ baja confiabilidad en el programa
    \item complejidad en las funciones 
      $\mapsto$ dificultad en el uso de las mismas
    \item complejidad en las estructuras usadas
      $\mapsto$ dificultades en la modificabilidad, problemas de seguridad
  \end{itemize}

\end{frame}


\begin{frame}[fragile]
  \frametitle{\textit{Conformity} (adaptaci\'on)}

  La f\'isica, y otras disciplinas, deben lidiar con objetos complejos, pero
  se basan en la expectativa de encontrar teor\'ias unificadas.
  Esta expectativa no conforta a la ingenier\'ia del \textit{software}.

  La complejidad con la que se encuentra una entidad de \textit{software}
  es arbitraria, generada por las muchas instituciones humanas y sistemas
  a los cuales, sus interfaces, deben acatar.

  En los (muchos) casos en que una entidad de \textit{software} debe adaptarse
  a otras interfaces, la complejidad que esto genera no puede ser simplificada
  por ning\'un redise\~no que incluya \'unicamente a dicha entidad.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Modificabilidad}
  A diferencia de los objetos manufacturados \textit{f\'isicamente} (edificios,
  autom\'obiles o computadoras), las entidades de \textit{software} continuamente
  est\'an siendo forzadas a cambiar.

  Los motivos principales son dos:
  \begin{itemize}
    \item la funcionalidad de un sistema suele necesitar extenderse o modificarse
    \item a diferencia de objetos f\'isicamente concretos, el \textit{software}
      es infinitamente modificable
  \end{itemize}

  Un sistema exitoso sufrir\'a modificaciones. Mientras se lo encuentre \'util,
  los usuarios lo utilizar\'an en escenarios no contemplados, en otros dominios.
  M\'as a\'un, un sistema exitoso sobrevivir\'a a las maquinas para las cuales
  fue inicialmente construido, que, sabemos, cambian continuamente.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Invisibilidad}
  El \textit{software} es invisibile, \textit{invisualizable}.
  Las abstracciones geom\'etricas suelen resaltar inconsistencias, pero
  la realidad del \textit{software} no est\'a naturalmente embebida
  en un espacio.

  Las herramientas m\'as comunes para la visualizaci\'on suelen ser poco claras,
  pues vemos demasiadas conexiones. Suele ser buena pr\'actica limitar los
  \textit{links} y preferir los grafos \textbf{jer\'arquicos}.

  La visualizaci\'on geom\'etrica es una de las herramientas conceptuales m\'as
  importantes de la mente humana. La dificultad de visualizar el \textit{software}
  no solo limita el dise\~no de una mente, \textbf{limita la comunicaci\'on entre
  varias mentes}.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Dificultades accidentales que fueron resueltas}

  \begin{itemize}
    \item[Lenguajes de alto nivel]
      Liberaron a los programas de mucha de su complejidad accidental.
      Nuesta sofisticaci\'on en c\'omo pensar las estructuras de datos, los tipos
      de datos y las operaciones, se encuentra en crecimiento, pero es un crecimiento
      cada vez m\'as limitado.
    \item[Tiempo compartido]
      El efecto principal es la r\'apida respuesta de un sistema. A medida que
      tiende a cero, el \textit{delay} se torna imperceptible. Mas all\'a de
      este punto no pueden esperarse beneficios particularmente importantes.
    \item[Ambientes de programaci\'on unificados]
      Atacan a las dificultades accidentales de comunicar m\'ultiples programas.
  \end{itemize}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Candidatos a \textit{silver bullet}}

  El lenguaje \textsc{Ada}.
  Esta secci\'on qued\'o un poco desactualizada, dada la enorme cantidad de
  lenguajes de alto nivel, especializados en resolver gran parte de los
  problemas accidentales con que se encuentra un programador.

  TODO: leer un poco sobre Ada.
\end{frame}


\begin{frame}[fragile]
  \frametitle{Programaci\'on orientada a objetos}
  Separamos dos conceptos ortogonales que llevan el mismo nombre.
  \begin{itemize}
    \item[Tipos abstractos de datos] El tipo de un objeto debe ser
      definido por un nombre, un conjunto de valores propios, y un conjunto
      de operaciones propias. \textbf{No} por su estructura interna.
    \item[Tipos jer\'arquicos] Permiten la definici\'on de interfaces generales
      que se pueden ir refinando, siempre que se lo necesite.
  \end{itemize}

  Dada su ortogonalidad pueden ser usados independientemente.
  Permiten evitar las dificultades accidentales de la implementaci\'on de un
  dise\~no, pero \textbf{la complejidad del dise\~no sigue siendo esencial}.
\end{frame}

\end{document}
